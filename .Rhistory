colnames(coping.nbr.ocir.raw.id)
#Differences
dim(coping.nbr.ocir.raw)[1]-dim(coping.nbr.ocir.raw.id)[1]
}
if(NBR == TRUE) {
coping.ocir.raw.id <- coping.nbr.ocir.raw.id
}
if(RAMP == TRUE) {
ramp.ocir.raw <- readRDS(file = paste0(data.raw_path, "/ramp/ocir_ramp.rds"))
dim(ramp.ocir.raw)
colnames(ramp.ocir.raw)
}
if(RAMP == TRUE) {
summarytools::dfSummary(
ramp.ocir.raw,
graph.col = F,
valid.col = F
#labels.col = F
)
}
if(RAMP == TRUE) {
ramp.ocir.raw.id <- ramp.ocir.raw %>%
drop_na(`Login ID`) %>% # Drop NAs
distinct(`Login ID`, .keep_all = TRUE) %>% # Remove duplicates based on ID
separate(`Login ID`, into = c("Sample", "ID"), sep = 4) %>% # Split ID in Sample and Number
mutate(ID = as.numeric(ID)) %>%
select(
Sample, # Sample
ID, # ID
ocir.felt_pandemic_feelings = ocir.feelings_pandemic_felt, # Comparison to before the pandemic
ocir.saved_things_retro = ocir.saved_things.1, #reordered items to reflect questionnaire
ocir.i_check_things_more_often_than_necessary_retro = ocir.i_check_things_more_often_than_necessary..1, #in RAMP .1 = retrospective
ocir.arranged_properly_objects_upset_retro = ocir.arranged_properly_objects_upset.1,
ocir.feel_compelled_count_things_retro = ocir.feel_compelled_count_things.1,
ocir.strangers_touch_touched_difficult_retro = ocir.touch_touched_strangers_object.1,
ocir.control_difficult_find_thoughts_retro = ocir.find_control_difficult_thoughts.1,
ocir.i_collect_things_i_dont_need_retro = ocir.i_collect_things_i_dont_need..1,
ocir.i_repeatedly_check_doors_windows_drawers_etc_retro = ocir.i_repeatedly_check_doors_windows_drawers_etc..1,
ocir.arranged_things_change_upset_retro = ocir.arranged_things_change_upset.1,
ocir.repeat_feel_numbers_retro = ocir.numbers_repeat_feel.1,
ocir.clean_simply_wash_feel_retro = ocir.feel_contaminated_clean_simply.1,
ocir.mind_upset_unpleasant_thoughts_retro = ocir.unpleasant_thoughts_mind_upset.1,
ocir.afraid_avoid_throwing_things_retro = ocir.afraid_avoid_throwing_things.1,
ocir.light_switches_water_taps_retro = ocir.repeatedly_check_gas_water.1,
ocir.arranged_things_retro = ocir.arranged_things.1,
ocir.good_feel_bad_numbers_retro = ocir.bad_numbers_good_feel.1,
ocir.hands_longer_wash_retro = ocir.longer_hands_wash.1,
ocir.frequently_difficulty_rid_nasty_retro = ocir.difficulty_rid_frequently_nasty.1,
ocir.saved_things_base = ocir.saved_things,
ocir.i_check_things_more_often_than_necessary_base = ocir.i_check_things_more_often_than_necessary.,
ocir.arranged_properly_objects_upset_base = ocir.arranged_properly_objects_upset,
ocir.feel_compelled_count_things_base = ocir.feel_compelled_count_things,
ocir.strangers_touch_touched_difficult_base = ocir.touch_touched_strangers_object,
ocir.control_difficult_find_thoughts_base = ocir.find_control_difficult_thoughts,
ocir.i_collect_things_i_dont_need_base = ocir.i_collect_things_i_dont_need.,
ocir.i_repeatedly_check_doors_windows_drawers_etc_base = ocir.i_repeatedly_check_doors_windows_drawers_etc.,
ocir.arranged_things_change_upset_base = ocir.arranged_things_change_upset,
ocir.repeat_feel_numbers_base = ocir.numbers_repeat_feel,
ocir.clean_simply_wash_feel_base = ocir.feel_contaminated_clean_simply,
ocir.mind_upset_unpleasant_thoughts_base = ocir.unpleasant_thoughts_mind_upset,
ocir.afraid_avoid_throwing_things_base = ocir.afraid_avoid_throwing_things,
ocir.light_switches_water_taps_base = ocir.repeatedly_check_gas_water,
ocir.arranged_things_base = ocir.arranged_things,
ocir.good_feel_bad_numbers_base = ocir.bad_numbers_good_feel,
ocir.hands_longer_wash_base = ocir.longer_hands_wash,
ocir.frequently_difficulty_rid_nasty_base = ocir.difficulty_rid_frequently_nasty
) %>%
add_numeric(., exclude = exclude_cols) %>%
mutate_if(is.numeric, ~na_if(., -88)) %>% # Recode missing values to NAs in numeric variables
mutate_if(is.numeric, ~na_if(., -99)) %>%
mutate_if(is.numeric, ~na_if(., -77)) %>%
mutate_if(is.factor, ~na_if(., "Seen but not answered")) %>% # Recode missing values to NAs in factor variables
mutate_if(is.factor, ~na_if(., "Don't know")) %>%
mutate_if(is.factor, ~na_if(., "Prefer not to say")) %>%
mutate_if(is.factor, ~na_if(., "Prefer not to answer")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Seen but not answered")) %>% # Drop empty factor levels
mutate_if(is.factor, ~forcats::fct_drop(., only = "Don't know")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Prefer not to answer")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Prefer not to say"))
# Inspect dimensions
dim(ramp.ocir.raw.id)
# Inspect colnames
colnames(ramp.ocir.raw.id)
#Differences
dim(ramp.ocir.raw)[1]-dim(ramp.ocir.raw.id)[1]
}
if(RAMP == TRUE) {
coping.ocir.raw.id <- ramp.ocir.raw.id
}
# Create vector with scoring key: If the item is reversed coded use -1.
# There needs to be the correct number of values for each item in the questionnaire.
ocir.items_key_retro <- c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
# Create vector with items that are included in total score
ocir.items_retro = c(
"ocir.i_repeatedly_check_doors_windows_drawers_etc_retro",
"ocir.arranged_things_change_upset_retro",
"ocir.repeat_feel_numbers_retro",
"ocir.clean_simply_wash_feel_retro",
"ocir.mind_upset_unpleasant_thoughts_retro",
"ocir.afraid_avoid_throwing_things_retro",
"ocir.light_switches_water_taps_retro",
"ocir.arranged_things_retro",
"ocir.good_feel_bad_numbers_retro",
"ocir.hands_longer_wash_retro",
"ocir.saved_things_retro",
"ocir.frequently_difficulty_rid_nasty_retro",
"ocir.i_check_things_more_often_than_necessary_retro",
"ocir.arranged_properly_objects_upset_retro",
"ocir.feel_compelled_count_things_retro",
"ocir.strangers_touch_touched_difficult_retro",
"ocir.control_difficult_find_thoughts_retro",
"ocir.i_collect_things_i_dont_need_retro"
)
# Calculate total score
ocir.scored_items_retro <- scoreItems(keys = ocir.items_key_retro,
items = coping.ocir.raw.id[ocir.items_retro],
totals = TRUE,
missing = TRUE,
impute = 'none',
min = 0,
max = 4)
# Add in column to tibble
coping.ocir.raw.id$ocir.sum_score_retro_raw <- ocir.scored_items_retro$scores
# Look at values
coping.ocir.raw.id %>%
descr(ocir.sum_score_retro_raw,
stats = "common"
)
# Create vector with scoring key: If the item is reversed coded use -1.
# There needs to be the correct number of values for each item in the questionnaire.
ocir.items_key_base <- c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
# Create vector with items that are included in total score
ocir.items_base = c(
"ocir.i_repeatedly_check_doors_windows_drawers_etc_base",
"ocir.arranged_things_change_upset_base",
"ocir.repeat_feel_numbers_base",
"ocir.clean_simply_wash_feel_base",
"ocir.mind_upset_unpleasant_thoughts_base",
"ocir.afraid_avoid_throwing_things_base",
"ocir.light_switches_water_taps_base",
"ocir.arranged_things_base",
"ocir.good_feel_bad_numbers_base",
"ocir.hands_longer_wash_base",
"ocir.saved_things_base",
"ocir.frequently_difficulty_rid_nasty_base",
"ocir.i_check_things_more_often_than_necessary_base",
"ocir.arranged_properly_objects_upset_base",
"ocir.feel_compelled_count_things_base",
"ocir.strangers_touch_touched_difficult_base",
"ocir.control_difficult_find_thoughts_base",
"ocir.i_collect_things_i_dont_need_base"
)
# Calculate total score
ocir.scored_items_base <- scoreItems(keys = ocir.items_key_base,
items = coping.ocir.raw.id[ocir.items_base],
totals = TRUE,
missing = TRUE,
impute = 'none',
min = 0,
max = 4)
# Add in column to tibble
coping.ocir.raw.id$ocir.sum_score_base_raw <- ocir.scored_items_base$scores
# Look at values
coping.ocir.raw.id %>%
descr(ocir.sum_score_base_raw,
stats = "common"
)
coping.ocir.raw.id <- coping.ocir.raw.id %>%
mutate(
na_per_person_ocir_retro =         # variable for NA per person
rowSums(
is.na(.[ocir.items_retro])
)
)
coping.ocir.raw.id %>%
freq(na_per_person_ocir_retro, cumul = F) #have a look at the frequency
coping.ocir.raw.id <- coping.ocir.raw.id %>%
mutate(
na_per_person_ocir_base =         # variable for NA per person
rowSums(
is.na(.[ocir.items_base])
)
)
coping.ocir.raw.id %>%
freq(na_per_person_ocir_base, cumul = F) #have a look at the frequency
coping.ocir.raw.id <- coping.ocir.raw.id %>%
mutate(
ocir.sum_score_base =
if_else(condition = na_per_person_ocir_base > 0,
true = NA_real_,
false = ocir.sum_score_base_raw,
missing = NA_real_
)
)
coping.ocir.raw.id %>%
descr(ocir.sum_score_base_raw, stats = "common")
coping.ocir.raw.id %>%
descr(ocir.sum_score_base, stats = "common")
coping.ocir.raw.id <- coping.ocir.raw.id %>%
mutate(
ocir.sum_score_retro =
if_else(condition = na_per_person_ocir_retro > 0,
true = NA_real_,
false = ocir.sum_score_retro_raw,
missing = NA_real_
)
)
coping.ocir.raw.id %>%
descr(ocir.sum_score_retro_raw, stats = "common")
coping.ocir.raw.id %>%
descr(ocir.sum_score_retro, stats = "common")
head(coping.ocir.raw.id)
summarytools::dfSummary(
coping.ocir.raw.id,
graph.col = F,
valid.col = F,
labels.col = F)
if(GLAD == TRUE){
glad.als.raw <- readRDS(file = paste0(data.raw_path, "/glad/alsfrs_coping_glad.rds"))
dim(glad.als.raw)
colnames(glad.als.raw)
}
if(GLAD == TRUE){
glad.als.raw <- readRDS(file = paste0(data.raw_path, "/glad/alsfrs_coping_glad.rds"))
dim(glad.als.raw)
colnames(glad.als.raw)
}
if(EDGI == TRUE){
edgi.als.raw <- readRDS(file = paste0(data.raw_path, "/edgi/alsfrs_coping_edgi.rds"))
dim(edgi.als.raw)
colnames(edgi.als.raw)
}
if(EDGI == TRUE) {
summarytools::dfSummary(
edgi.als.raw,
graph.col = F,
valid.col = F,
labels.col = F
)
}
if(EDGI == TRUE){
edgi.als.raw.id <- edgi.als.raw %>%
drop_na(externalDataReference) %>% # Drop NAs
distinct(externalDataReference, .keep_all = TRUE) %>% # Remove duplicates based on ID
separate(externalDataReference, into = c("Sample", "ID"), sep = 4) %>% # Split ID in Sample and Number
mutate(ID = as.numeric(ID)) %>%
select(
Sample, # Sample
ID, # ID
alsfrs.limb_weakness_noticed_past,
alsfrs.normal,
alsfrs.slow_or_sloppy_all_words_are_legible,
alsfrs.not_all_words_are_legible,
alsfrs.able_to_grip_pen,
alsfrs.unable_to_grip_pen,
alsfrs.have_you_noticed_any_difficulty_walking,
alsfrs.do_you_have_any_difficulty_climbing_stairs
) %>%
add_numeric(., exclude = exclude_cols) %>%
mutate_if(is.numeric, ~na_if(., -88)) %>% # Recode missing values to NAs in numeric variables
mutate_if(is.numeric, ~na_if(., -99)) %>%
mutate_if(is.numeric, ~na_if(., -77)) %>%
mutate_if(is.factor, ~na_if(., "Seen but not answered")) %>% # Recode missing values to NAs in factor variables
mutate_if(is.factor, ~na_if(., "Don't know")) %>%
mutate_if(is.factor, ~na_if(., "Prefer not to say")) %>%
mutate_if(is.factor, ~na_if(., "Prefer not to answer")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Seen but not answered")) %>% # Drop empty factor levels
mutate_if(is.factor, ~forcats::fct_drop(., only = "Don't know")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Prefer not to answer")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Prefer not to say"))
# Inspect dimensions
dim(edgi.als.raw.id)
# Inspect colnames
colnames(edgi.als.raw.id)
#Differences
dim(edgi.als.raw)[1]-dim(edgi.als.raw.id)[1]
}
# Inspect dimensions
dim(edgi.als.raw.id)
# Inspect colnames
colnames(edgi.als.raw.id)
#Differences
dim(edgi.als.raw)[1]-dim(edgi.als.raw.id)[1]
if(EDGI == TRUE) {
summarytools::dfSummary(
edgi.als.raw,
graph.col = F,
valid.col = F,
#  labels.col = F
)
}
if(EDGI == TRUE) {
summarytools::dfSummary(
als.raw.id,
graph.col = F,
valid.col = F,
#  labels.col = F
)
}
if(EDGI == TRUE){
als.raw.id <- edgi.als.raw.id
}
if(EDGI == TRUE) {
summarytools::dfSummary(
als.raw.id,
graph.col = F,
valid.col = F,
#  labels.col = F
)
}
EDGI
if(GLAD == TRUE) {
summarytools::dfSummary(
glad.als.raw,
graph.col = F,
valid.col = F,
labels.col = F
)
}
if(GLAD == TRUE){
glad.als.raw <- readRDS(file = paste0(data.raw_path, "/glad/alsfrs_coping_glad.rds"))
dim(glad.als.raw)
colnames(glad.als.raw)
}
if(GLAD == TRUE) {
summarytools::dfSummary(
glad.als.raw,
graph.col = F,
valid.col = F,
labels.col = F
)
}
if(GLAD == TRUE) {
summarytools::dfSummary(
glad.als.raw,
graph.col = F,
valid.col = F,
labels.col = F
)
}
glad.als.raw <- readRDS(file = paste0(data.raw_path, "/glad/alsfrs_coping_glad.rds"))
summarytools::dfSummary(
glad.als.raw,
graph.col = F,
valid.col = F,
labels.col = F
)
colnames(glad.als.raw)
glad.als.raw.id <- glad.als.raw %>%
drop_na(externalDataReference) %>% # Drop NAs
distinct(externalDataReference, .keep_all = TRUE) %>% # Remove duplicates based on ID
separate(externalDataReference, into = c("Sample", "ID"), sep = 4) %>% # Split ID in Sample and Number
mutate(ID = as.numeric(ID)) %>%
select(
Sample, # Sample
ID, # ID
alsfrs.limb_weakness_noticed_past,
alsfrs.normal,
alsfrs.slow_or_sloppy_all_words_are_legible,
alsfrs.not_all_words_are_legible,
alsfrs.able_to_grip_pen,
alsfrs.unable_to_grip_pen,
alsfrs.have_you_noticed_any_difficulty_walking,
alsfrs.do_you_have_any_difficulty_climbing_stairs
) %>%
add_numeric(., exclude = exclude_cols) %>%
mutate_if(is.numeric, ~na_if(., -88)) %>% # Recode missing values to NAs in numeric variables
mutate_if(is.numeric, ~na_if(., -99)) %>%
mutate_if(is.numeric, ~na_if(., -77)) %>%
mutate_if(is.factor, ~na_if(., "Seen but not answered")) %>% # Recode missing values to NAs in factor variables
mutate_if(is.factor, ~na_if(., "Don't know")) %>%
mutate_if(is.factor, ~na_if(., "Prefer not to say")) %>%
mutate_if(is.factor, ~na_if(., "Prefer not to answer")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Seen but not answered")) %>% # Drop empty factor levels
mutate_if(is.factor, ~forcats::fct_drop(., only = "Don't know")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Prefer not to answer")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Prefer not to say"))
# Inspect dimensions
dim(glad.als.raw.id)
# Inspect colnames
colnames(glad.als.raw.id)
#Differences
dim(glad.als.raw)[1]-dim(glad.als.raw.id)[1]
dim(glad.als.raw)
colnames(glad.als.raw)
glad.als.raw <- readRDS(file = paste0(data.raw_path, "/glad/alsfrs_coping_glad.rds"))
dim(glad.als.raw)
colnames(glad.als.raw)
edgi.als.raw <- readRDS(file = paste0(data.raw_path, "/edgi/alsfrs_coping_edgi.rds"))
dim(edgi.als.raw)
colnames(edgi.als.raw)
edgi.als.raw.id <- edgi.als.raw %>%
drop_na(externalDataReference) %>% # Drop NAs
distinct(externalDataReference, .keep_all = TRUE) %>% # Remove duplicates based on ID
separate(externalDataReference, into = c("Sample", "ID"), sep = 4) %>% # Split ID in Sample and Number
mutate(ID = as.numeric(ID)) %>%
select(
Sample, # Sample
ID, # ID
alsfrs.limb_weakness_noticed_past,
alsfrs.normal,
alsfrs.slow_or_sloppy_all_words_are_legible,
alsfrs.not_all_words_are_legible,
alsfrs.able_to_grip_pen,
alsfrs.unable_to_grip_pen,
alsfrs.have_you_noticed_any_difficulty_walking,
alsfrs.do_you_have_any_difficulty_climbing_stairs
) %>%
add_numeric(., exclude = exclude_cols) %>%
mutate_if(is.numeric, ~na_if(., -88)) %>% # Recode missing values to NAs in numeric variables
mutate_if(is.numeric, ~na_if(., -99)) %>%
mutate_if(is.numeric, ~na_if(., -77)) %>%
mutate_if(is.factor, ~na_if(., "Seen but not answered")) %>% # Recode missing values to NAs in factor variables
mutate_if(is.factor, ~na_if(., "Don't know")) %>%
mutate_if(is.factor, ~na_if(., "Prefer not to say")) %>%
mutate_if(is.factor, ~na_if(., "Prefer not to answer")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Seen but not answered")) %>% # Drop empty factor levels
mutate_if(is.factor, ~forcats::fct_drop(., only = "Don't know")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Prefer not to answer")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Prefer not to say"))
# Inspect dimensions
dim(edgi.als.raw.id)
# Inspect colnames
colnames(edgi.als.raw.id)
#Differences
dim(edgi.als.raw)[1]-dim(edgi.als.raw.id)[1]
nbr.als.raw <- readRDS(file = paste0(data.raw_path, "/nbr/alsfrs_coping_nbr.rds"))
dim(nbr.als.raw)
colnames(nbr.als.raw)
nbr.als.raw.id <- nbr.als.raw %>%
drop_na(subjectid) %>% # Drop NAs
distinct(subjectid, .keep_all = TRUE) %>% # Remove duplicates based on ID
separate(subjectid, into = c("Sample", "ID"), sep = 4) %>% # Split ID in Sample and Number
mutate(ID = as.numeric(ID)) %>%
select(
Sample, # Sample
ID, # ID
alsfrs.limb_weakness_noticed_past,
alsfrs.normal,
alsfrs.slow_or_sloppy_all_words_are_legible,
alsfrs.not_all_words_are_legible,
alsfrs.able_to_grip_pen,
alsfrs.unable_to_grip_pen,
alsfrs.have_you_noticed_any_difficulty_walking,
alsfrs.do_you_have_any_difficulty_climbing_stairs
) %>%
add_numeric(., exclude = exclude_cols) %>%
mutate_if(is.numeric, ~na_if(., -88)) %>% # Recode missing values to NAs in numeric variables
mutate_if(is.numeric, ~na_if(., -99)) %>%
mutate_if(is.numeric, ~na_if(., -77)) %>%
mutate_if(is.factor, ~na_if(., "Seen but not answered")) %>% # Recode missing values to NAs in factor variables
mutate_if(is.factor, ~na_if(., "Don't know")) %>%
mutate_if(is.factor, ~na_if(., "Prefer not to say")) %>%
mutate_if(is.factor, ~na_if(., "Prefer not to answer")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Seen but not answered")) %>% # Drop empty factor levels
mutate_if(is.factor, ~forcats::fct_drop(., only = "Don't know")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Prefer not to answer")) %>%
mutate_if(is.factor, ~forcats::fct_drop(., only = "Prefer not to say"))
head(nbr.als.raw)
knitr::opts_chunk$set(echo = FALSE,
comment=NA,
prompt=FALSE,
cache=FALSE)
options(bitmapType = 'quartz') # to render fonts better
remove(list = ls())
date = Sys.Date()
library(tidyverse)
library(skimr)
#source raw data directory: data.raw_path
source("../PANCHANGE_raw_path.R")
glad <- read_rds(path = paste0(data_path, "/glad.rds"))
dim(glad)
edgi <- read_rds(path = paste0(data_path, "/edgi.rds"))
dim(edgi)
nbr <- read_rds(path = paste0(data_path, "/nbr.rds"))
dim(nbr)
ramp <- read_rds(path = paste0(data_path, "/ramp.rds"))
dim(ramp)
dat <- bind_rows(
glad,
edgi,
nbr,
ramp
)
knitr::opts_chunk$set(echo = FALSE,
comment=NA,
prompt=FALSE,
cache=FALSE)
options(bitmapType = 'quartz') # to render fonts better
remove(list = ls())
date = Sys.Date()
library(tidyverse)
library(skimr)
#source raw data directory: data.raw_path
source("../PANCHANGE_raw_path.R")
glad <- read_rds(path = paste0(data_path, "/glad.rds"))
dim(glad)
edgi <- read_rds(path = paste0(data_path, "/edgi.rds"))
dim(edgi)
nbr <- read_rds(path = paste0(data_path, "/nbr.rds"))
dim(nbr)
ramp <- read_rds(path = paste0(data_path, "/ramp.rds"))
dim(ramp)
dat <- bind_rows(
glad,
edgi,
nbr,
ramp
)
#look at the data
skimr::skim(dat)
saveRDS(object = dat, file = paste0(data_path, "/four_cohorts.rds"))
